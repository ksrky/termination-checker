fib(n) =
    if n == 0 then 1
    else if n == 1 then 1
    else fib(n-1) + fib(n-2).

-- fib(n-1) : ∀n. ¬(n == 0) ∧ ¬(n == 1) => n > n - 1
-- fib(n-2) : ∀n. ¬(n == 0) ∧ ¬(n == 1) => n > n - 2

ack(m, n) =
    if m == 0 then 1
    else if n == 0 then ack(m-1,1)
    else ack(m-1, ack(m, n-1)).

-- 1st arg at ack(m-1,1) : ∀m n. ¬(m == 0) ∧ n == 0 => m > m - 1
-- 2nd arg at ack(m-1,1) : ∀m n. ¬(m == 0) ∧ n == 0 => n > 1
-- 1st arg at ack(m-1,ack(m, n-1)) : ∀m n. ¬(m == 0) ∧ ¬(n == 0) => m > m - 1
-- 2nd arg at ack(m-1,ack(m, n-1)) : ∀m n. ¬(m == 0) ∧ ¬(n == 0) => n > ack(m, n-1)
-- 1st arg at ack(m, n-1) : ∀m n. ¬(m == 0) ∧ ¬(n == 0) => m > m
-- 2nd arg at ack(m, n-1) : ∀m n. ¬(m == 0) ∧ ¬(n == 0) => n > n-1

gcd(m, n) =
    if n == 0 then m
    else if n > m then gcd(n, m)
    else gcd(m-n, n).

-- 1st arg at gcd(m,n) : ∀m n. ¬(n == 0) ∧ n > m => gcd(n, m)
-- 2nd arg at gcd(m,n) : ∀m n. ¬(n == 0) ∧ ¬(n > m) => gcd(m-n, n)
